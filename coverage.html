
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/circonus-labs/circonus-logwatch/cmd/root.go (87.4%)</option>
				
				<option value="file1">github.com/circonus-labs/circonus-logwatch/internal/agent/main.go (56.4%)</option>
				
				<option value="file2">github.com/circonus-labs/circonus-logwatch/internal/agent/sighndlr_bsdsol.go (8.3%)</option>
				
				<option value="file3">github.com/circonus-labs/circonus-logwatch/internal/appstats/main.go (75.8%)</option>
				
				<option value="file4">github.com/circonus-labs/circonus-logwatch/internal/config/defaults/main.go (76.5%)</option>
				
				<option value="file5">github.com/circonus-labs/circonus-logwatch/internal/config/main.go (90.4%)</option>
				
				<option value="file6">github.com/circonus-labs/circonus-logwatch/internal/configs/main.go (87.0%)</option>
				
				<option value="file7">github.com/circonus-labs/circonus-logwatch/internal/metrics/circonus/main.go (95.0%)</option>
				
				<option value="file8">github.com/circonus-labs/circonus-logwatch/internal/metrics/logonly/main.go (100.0%)</option>
				
				<option value="file9">github.com/circonus-labs/circonus-logwatch/internal/metrics/statsd/main.go (86.7%)</option>
				
				<option value="file10">github.com/circonus-labs/circonus-logwatch/internal/release/main.go (100.0%)</option>
				
				<option value="file11">github.com/circonus-labs/circonus-logwatch/internal/watcher/main.go (71.7%)</option>
				
				<option value="file12">github.com/circonus-labs/circonus-logwatch/main.go (80.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Copyright © 2017 Circonus, Inc. &lt;support@circonus.com&gt;
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
//

package cmd

import (
        "fmt"
        stdlog "log"
        "os"
        "time"

        "github.com/circonus-labs/circonus-logwatch/internal/agent"
        "github.com/circonus-labs/circonus-logwatch/internal/config"
        "github.com/circonus-labs/circonus-logwatch/internal/config/defaults"
        "github.com/circonus-labs/circonus-logwatch/internal/release"
        "github.com/pkg/errors"
        "github.com/rs/zerolog"
        "github.com/rs/zerolog/log"
        "github.com/spf13/cobra"
        "github.com/spf13/viper"
)

var cfgFile string

// RootCmd represents the base command when called without any subcommands
var RootCmd = &amp;cobra.Command{
        Use:   release.NAME,
        Short: "A small utility to send metrics extracted from log files to Circonus.",
        Long: `Send metrics extracted from log files to Circonus.

Not all useful metrics can be sent directly to a centralized system for analysis
and alerting. Often, there are valuable metrics sequesterd in system and application
log files. These logs are not always in a common, easily parsable format.

Using named regular expressions and templates, this utility offers the ability
to extract these metrics from the logs and send them directly to the Circonus
system using one of several methods.

See https://github.com/circonus-labs/circonus-logwatch/etc for example configurations.
`,
        PersistentPreRunE: initLogging,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                //
                // show version and exit
                //
                if viper.GetBool(config.KeyShowVersion) </span><span class="cov0" title="0">{
                        fmt.Printf("%s v%s - commit: %s, date: %s, tag: %s\n", release.NAME, release.VERSION, release.COMMIT, release.DATE, release.TAG)
                        return
                }</span>

                //
                // show configuration and exit
                //
                <span class="cov0" title="0">if viper.GetString(config.KeyShowConfig) != "" </span><span class="cov0" title="0">{
                        if err := config.ShowConfig(os.Stdout); err != nil </span><span class="cov0" title="0">{
                                log.Fatal().Err(err).Msg("show-config")
                        }</span>
                        <span class="cov0" title="0">return</span>
                }

                <span class="cov0" title="0">log.Info().
                        Int("pid", os.Getpid()).
                        Str("name", release.NAME).
                        Str("ver", release.VERSION).Msg("Starting")

                a, err := agent.New()
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal().Err(err).Msg("Initializing")
                }</span>

                <span class="cov0" title="0">config.StatConfig()

                if err := a.Start(); err != nil </span><span class="cov0" title="0">{
                        log.Fatal().Err(err).Msg("Startup")
                }</span>

        },
}

// Execute adds all child commands to the root command and sets flags appropriately.
// This is called by main.main(). It only needs to happen once to the rootCmd.
func Execute() <span class="cov0" title="0">{
        if err := RootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                fmt.Println(err)
                os.Exit(1)
        }</span>
}

func init() <span class="cov1" title="1">{
        zerolog.TimeFieldFormat = time.RFC3339Nano
        zerolog.SetGlobalLevel(zerolog.InfoLevel)
        zlog := zerolog.New(zerolog.SyncWriter(os.Stderr)).With().Timestamp().Logger()
        log.Logger = zlog

        stdlog.SetFlags(0)
        stdlog.SetOutput(zlog)

        cobra.OnInitialize(initConfig)

        desc := func(desc, env string) string </span><span class="cov10" title="21">{
                return fmt.Sprintf("[ENV: %s] %s", env, desc)
        }</span>

        //
        // Basic
        //
        <span class="cov1" title="1">{
                var (
                        longOpt     = "config"
                        shortOpt    = "c"
                        description = "config file (default is " + defaults.EtcPath + "/" + release.NAME + ".(json|toml|yaml)"
                )
                RootCmd.PersistentFlags().StringVarP(&amp;cfgFile, longOpt, shortOpt, "", description)
        }</span>

        <span class="cov1" title="1">{
                const (
                        key         = config.KeyLogConfDir
                        longOpt     = "log-conf-dir"
                        shortOpt    = "l"
                        envVar      = release.ENVPREFIX + "_PLUGIN_DIR"
                        description = "Log configuration directory"
                )

                RootCmd.Flags().StringP(longOpt, shortOpt, defaults.LogConfPath, desc(description, envVar))
                viper.BindPFlag(key, RootCmd.Flags().Lookup(longOpt))
                viper.BindEnv(key, envVar)
                viper.SetDefault(key, defaults.LogConfPath)
        }</span>

        //
        // Destination for metrics
        //
        <span class="cov1" title="1">{
                const (
                        key         = config.KeyDestType
                        longOpt     = "dest"
                        envVar      = release.ENVPREFIX + "_DESTINATION"
                        description = "Destination[agent|check|log|statsd] type for metrics"
                )

                RootCmd.Flags().String(longOpt, defaults.DestinationType, desc(description, envVar))
                viper.BindPFlag(key, RootCmd.Flags().Lookup(longOpt))
                viper.BindEnv(key, envVar)
                viper.SetDefault(key, defaults.DestinationType)
        }</span>
        <span class="cov1" title="1">{
                const (
                        key         = config.KeyDestCfgID
                        longOpt     = "dest-id"
                        envVar      = release.ENVPREFIX + "_DEST_ID"
                        description = "Destination[statsd|agent] metric group ID"
                )

                RootCmd.Flags().String(longOpt, release.NAME, desc(description, envVar))
                viper.BindPFlag(key, RootCmd.Flags().Lookup(longOpt))
                viper.BindEnv(key, envVar)
        }</span>
        <span class="cov1" title="1">{
                const (
                        key         = config.KeyDestCfgCID
                        longOpt     = "dest-cid"
                        envVar      = release.ENVPREFIX + "_DEST_CID"
                        description = "Destination[check] Check Bundle ID"
                )

                RootCmd.Flags().String(longOpt, "", desc(description, envVar))
                viper.BindPFlag(key, RootCmd.Flags().Lookup(longOpt))
                viper.BindEnv(key, envVar)
        }</span>
        <span class="cov1" title="1">{
                const (
                        key         = config.KeyDestCfgURL
                        longOpt     = "dest-url"
                        envVar      = release.ENVPREFIX + "_DEST_URL"
                        description = "Destination[check] Check Submission URL"
                )

                RootCmd.Flags().String(longOpt, "", desc(description, envVar))
                viper.BindPFlag(key, RootCmd.Flags().Lookup(longOpt))
                viper.BindEnv(key, envVar)
        }</span>
        <span class="cov1" title="1">{
                const (
                        key         = config.KeyDestCfgPort
                        longOpt     = "dest-port"
                        envVar      = release.ENVPREFIX + "_DEST_PORT"
                        description = "Destination[agent|statsd] port (agent=2609, statsd=8125)"
                )

                RootCmd.Flags().String(longOpt, "", desc(description, envVar))
                viper.BindPFlag(key, RootCmd.Flags().Lookup(longOpt))
                viper.BindEnv(key, envVar)
        }</span>
        <span class="cov1" title="1">{
                const (
                        key         = config.KeyDestCfgInstanceID
                        longOpt     = "dest-instance-id"
                        envVar      = release.ENVPREFIX + "_DEST_INSTANCE_ID"
                        description = "Destination[check] Check Instance ID"
                )

                RootCmd.Flags().String(longOpt, "", desc(description, envVar))
                viper.BindPFlag(key, RootCmd.Flags().Lookup(longOpt))
                viper.BindEnv(key, envVar)
        }</span>
        <span class="cov1" title="1">{
                const (
                        key         = config.KeyDestCfgTarget
                        longOpt     = "dest-target"
                        envVar      = release.ENVPREFIX + "_DEST_TARGET"
                        description = "Destination[check] Check target (default hostname)"
                )

                RootCmd.Flags().String(longOpt, "", desc(description, envVar))
                viper.BindPFlag(key, RootCmd.Flags().Lookup(longOpt))
                viper.BindEnv(key, envVar)
        }</span>
        <span class="cov1" title="1">{
                const (
                        key         = config.KeyDestCfgSearchTag
                        longOpt     = "dest-tag"
                        envVar      = release.ENVPREFIX + "_DEST_TAG"
                        description = "Destination[check] Check search tag"
                )

                RootCmd.Flags().String(longOpt, "", desc(description, envVar))
                viper.BindPFlag(key, RootCmd.Flags().Lookup(longOpt))
                viper.BindEnv(key, envVar)
        }</span>
        <span class="cov1" title="1">{
                const (
                        key         = config.KeyDestCfgStatsdPrefix
                        longOpt     = "dest-statsd-prefix"
                        envVar      = release.ENVPREFIX + "_DEST_STATSD_PREFIX"
                        description = "Destination[statsd] Prefix prepended to every metric sent to StatsD"
                )

                RootCmd.Flags().String(longOpt, defaults.StatsdPrefix, desc(description, envVar))
                viper.BindPFlag(key, RootCmd.Flags().Lookup(longOpt))
                viper.BindEnv(key, envVar)
                viper.SetDefault(key, defaults.StatsdPrefix)
        }</span>

        //
        // API
        //
        <span class="cov1" title="1">{
                const (
                        key          = config.KeyAPITokenKey
                        longOpt      = "api-key"
                        defaultValue = ""
                        envVar       = release.ENVPREFIX + "_API_KEY"
                        description  = "Circonus API Token key or 'cosi' to use COSI config"
                )
                RootCmd.Flags().String(longOpt, defaultValue, desc(description, envVar))
                viper.BindPFlag(key, RootCmd.Flags().Lookup(longOpt))
                viper.BindEnv(key, envVar)
        }</span>

        <span class="cov1" title="1">{
                const (
                        key         = config.KeyAPITokenApp
                        longOpt     = "api-app"
                        envVar      = release.ENVPREFIX + "_API_APP"
                        description = "Circonus API Token app"
                )

                RootCmd.Flags().String(longOpt, defaults.APIApp, desc(description, envVar))
                viper.BindPFlag(key, RootCmd.Flags().Lookup(longOpt))
                viper.BindEnv(key, envVar)
                viper.SetDefault(key, defaults.APIApp)
        }</span>

        <span class="cov1" title="1">{
                const (
                        key         = config.KeyAPIURL
                        longOpt     = "api-url"
                        envVar      = release.ENVPREFIX + "_API_URL"
                        description = "Circonus API URL"
                )

                RootCmd.Flags().String(longOpt, defaults.APIURL, desc(description, envVar))
                viper.BindPFlag(key, RootCmd.Flags().Lookup(longOpt))
                viper.BindEnv(key, envVar)
                viper.SetDefault(key, defaults.APIURL)
        }</span>

        <span class="cov1" title="1">{
                const (
                        key          = config.KeyAPICAFile
                        longOpt      = "api-ca-file"
                        defaultValue = ""
                        envVar       = release.ENVPREFIX + "_API_CA_FILE"
                        description  = "Circonus API CA certificate file"
                )

                RootCmd.Flags().String(longOpt, defaultValue, desc(description, envVar))
                viper.BindPFlag(key, RootCmd.Flags().Lookup(longOpt))
                viper.BindEnv(key, envVar)
        }</span>

        // Miscellenous

        <span class="cov1" title="1">{
                const (
                        key         = config.KeyDebug
                        longOpt     = "debug"
                        shortOpt    = "d"
                        envVar      = release.ENVPREFIX + "_DEBUG"
                        description = "Enable debug messages"
                )

                RootCmd.Flags().BoolP(longOpt, shortOpt, defaults.Debug, desc(description, envVar))
                viper.BindPFlag(key, RootCmd.Flags().Lookup(longOpt))
                viper.BindEnv(key, envVar)
                viper.SetDefault(key, defaults.Debug)
        }</span>

        <span class="cov1" title="1">{
                const (
                        key          = config.KeyDebugCGM
                        longOpt      = "debug-cgm"
                        defaultValue = false
                        envVar       = release.ENVPREFIX + "_DEBUG_CGM"
                        description  = "Enable CGM &amp; API debug messages"
                )

                RootCmd.Flags().Bool(longOpt, defaultValue, desc(description, envVar))
                viper.BindPFlag(key, RootCmd.Flags().Lookup(longOpt))
                viper.BindEnv(key, envVar)
                viper.SetDefault(key, defaultValue)
        }</span>

        <span class="cov1" title="1">{
                const (
                        key          = config.KeyDebugTail
                        longOpt      = "debug-tail"
                        defaultValue = false
                        envVar       = release.ENVPREFIX + "_DEBUG_TAIL"
                        description  = "Enable log tailing messages"
                )

                RootCmd.Flags().Bool(longOpt, defaultValue, desc(description, envVar))
                viper.BindPFlag(key, RootCmd.Flags().Lookup(longOpt))
                viper.BindEnv(key, envVar)
                viper.SetDefault(key, defaultValue)
        }</span>

        <span class="cov1" title="1">{
                const (
                        key          = config.KeyDebugMetric
                        longOpt      = "debug-metric"
                        defaultValue = false
                        envVar       = release.ENVPREFIX + "_DEBUG_METRIC"
                        description  = "Enable metric rule evaluation tracing debug messages"
                )

                RootCmd.Flags().Bool(longOpt, defaultValue, desc(description, envVar))
                viper.BindPFlag(key, RootCmd.Flags().Lookup(longOpt))
                viper.BindEnv(key, envVar)
                viper.SetDefault(key, defaultValue)
        }</span>

        <span class="cov1" title="1">{
                const (
                        key         = config.KeyAppStatPort
                        longOpt     = "stat-port"
                        envVar      = release.ENVPREFIX + "_STAT_PORT"
                        description = "Exposes app stats while running"
                )

                RootCmd.Flags().String(longOpt, defaults.AppStatPort, desc(description, envVar))
                viper.BindPFlag(key, RootCmd.Flags().Lookup(longOpt))
                viper.BindEnv(key, envVar)
                viper.SetDefault(key, defaults.AppStatPort)
        }</span>

        <span class="cov1" title="1">{
                const (
                        key         = config.KeyLogLevel
                        longOpt     = "log-level"
                        envVar      = release.ENVPREFIX + "_LOG_LEVEL"
                        description = "Log level [(panic|fatal|error|warn|info|debug|disabled)]"
                )

                RootCmd.Flags().String(longOpt, defaults.LogLevel, desc(description, envVar))
                viper.BindPFlag(key, RootCmd.Flags().Lookup(longOpt))
                viper.BindEnv(key, envVar)
                viper.SetDefault(key, defaults.LogLevel)
        }</span>

        <span class="cov1" title="1">{
                const (
                        key         = config.KeyLogPretty
                        longOpt     = "log-pretty"
                        envVar      = release.ENVPREFIX + "_LOG_PRETTY"
                        description = "Output formatted/colored log lines"
                )

                RootCmd.Flags().Bool(longOpt, defaults.LogPretty, desc(description, envVar))
                viper.BindPFlag(key, RootCmd.Flags().Lookup(longOpt))
                viper.BindEnv(key, envVar)
                viper.SetDefault(key, defaults.LogPretty)
        }</span>

        <span class="cov1" title="1">{
                const (
                        key          = config.KeyShowVersion
                        longOpt      = "version"
                        shortOpt     = "V"
                        defaultValue = false
                        description  = "Show version and exit"
                )
                RootCmd.Flags().BoolP(longOpt, shortOpt, defaultValue, description)
                viper.BindPFlag(key, RootCmd.Flags().Lookup(longOpt))
        }</span>

        <span class="cov1" title="1">{
                const (
                        key         = config.KeyShowConfig
                        longOpt     = "show-config"
                        description = "Show config (json|toml|yaml) and exit"
                )

                RootCmd.Flags().String(longOpt, "", description)
                viper.BindPFlag(key, RootCmd.Flags().Lookup(longOpt))
        }</span>

}

// initConfig reads in config file and ENV variables if set.
func initConfig() <span class="cov1" title="1">{
        if cfgFile != "" </span><span class="cov0" title="0">{
                viper.SetConfigFile(cfgFile)
        }</span><span class="cov1" title="1"> else {
                viper.AddConfigPath(defaults.EtcPath)
                viper.AddConfigPath(".")
                viper.SetConfigName(release.NAME)
        }</span>

        <span class="cov1" title="1">viper.AutomaticEnv()

        if err := viper.ReadInConfig(); err != nil </span><span class="cov1" title="1">{
                f := viper.ConfigFileUsed()
                if f != "" </span><span class="cov0" title="0">{
                        log.Fatal().Err(err).Str("config_file", f).Msg("Unable to load config file")
                }</span>
        }
}

// initLogging initializes zerolog
func initLogging(cmd *cobra.Command, args []string) error <span class="cov7" title="9">{
        //
        // Enable formatted output
        //
        if viper.GetBool(config.KeyLogPretty) </span><span class="cov0" title="0">{
                log.Logger = log.Output(zerolog.ConsoleWriter{Out: os.Stdout})
        }</span>

        //
        // Enable debug logging, if requested
        // otherwise, default to info level and set custom level, if specified
        //
        <span class="cov7" title="9">if viper.GetBool(config.KeyDebug) </span><span class="cov1" title="1">{
                viper.Set(config.KeyLogLevel, "debug")
                zerolog.SetGlobalLevel(zerolog.DebugLevel)
                log.Debug().Msg("--debug flag, forcing debug log level")
        }</span><span class="cov7" title="8"> else {
                if viper.IsSet(config.KeyLogLevel) </span><span class="cov7" title="8">{
                        level := viper.GetString(config.KeyLogLevel)

                        switch level </span>{
                        case "panic":<span class="cov1" title="1">
                                zerolog.SetGlobalLevel(zerolog.PanicLevel)</span>
                        case "fatal":<span class="cov1" title="1">
                                zerolog.SetGlobalLevel(zerolog.FatalLevel)</span>
                        case "error":<span class="cov1" title="1">
                                zerolog.SetGlobalLevel(zerolog.ErrorLevel)</span>
                        case "warn":<span class="cov1" title="1">
                                zerolog.SetGlobalLevel(zerolog.WarnLevel)</span>
                        case "info":<span class="cov1" title="1">
                                zerolog.SetGlobalLevel(zerolog.InfoLevel)</span>
                        case "debug":<span class="cov1" title="1">
                                zerolog.SetGlobalLevel(zerolog.DebugLevel)</span>
                        case "disabled":<span class="cov1" title="1">
                                zerolog.SetGlobalLevel(zerolog.Disabled)</span>
                        default:<span class="cov1" title="1">
                                return errors.Errorf("Unknown log level (%s)", level)</span>
                        }

                        <span class="cov6" title="7">log.Debug().Str("log-level", level).Msg("Logging level")</span>
                }
        }

        <span class="cov7" title="8">return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Copyright © 2017 Circonus, Inc. &lt;support@circonus.com&gt;
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
//

package agent

import (
        "expvar"
        "net"
        "net/http"
        "os"
        "os/signal"

        "github.com/circonus-labs/circonus-logwatch/internal/config"
        "github.com/circonus-labs/circonus-logwatch/internal/configs"
        "github.com/circonus-labs/circonus-logwatch/internal/metrics/circonus"
        "github.com/circonus-labs/circonus-logwatch/internal/metrics/logonly"
        "github.com/circonus-labs/circonus-logwatch/internal/metrics/statsd"
        "github.com/circonus-labs/circonus-logwatch/internal/release"
        "github.com/circonus-labs/circonus-logwatch/internal/watcher"
        "github.com/pkg/errors"
        "github.com/rs/zerolog/log"
        "github.com/spf13/viper"
)

func init() <span class="cov1" title="1">{
        http.Handle("/stats", expvar.Handler())
}</span>

// New returns a new agent instance
func New() (*Agent, error) <span class="cov10" title="4">{
        a := Agent{
                signalCh: make(chan os.Signal),
        }

        //
        // validate the configuration
        //
        if err := config.Validate(); err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="3">dest := viper.GetString(config.KeyDestType)
        switch dest </span>{
        case "agent":<span class="cov0" title="0">
                fallthrough</span>
        case "check":<span class="cov0" title="0">
                d, err := circonus.New()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">a.destClient = d</span>

        case "statsd":<span class="cov0" title="0">
                d, err := statsd.New()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">a.destClient = d</span>

        case "log":<span class="cov8" title="3">
                d, err := logonly.New()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="3">a.destClient = d</span>

        default:<span class="cov0" title="0">
                return nil, errors.Errorf("unknown metric destination (%s)", dest)</span>
        }

        <span class="cov8" title="3">cfgs, err := configs.Load()
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov5" title="2">if len(cfgs) == 0 </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov5" title="2">a.watchers = make([]*watcher.Watcher, len(cfgs))
        for idx, cfg := range cfgs </span><span class="cov5" title="2">{
                w, err := watcher.New(a.destClient, cfg)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error().Err(err).Str("id", cfg.ID).Msg("adding watcher, log will NOT be processed")
                }</span>
                <span class="cov5" title="2">a.watchers[idx] = w</span>
        }

        <span class="cov5" title="2">a.svrHTTP = &amp;http.Server{Addr: net.JoinHostPort("localhost", viper.GetString(config.KeyAppStatPort))}
        a.svrHTTP.SetKeepAlivesEnabled(false)

        a.setupSignalHandler()

        return &amp;a, nil</span>
}

// Start the agent
func (a *Agent) Start() error <span class="cov0" title="0">{
        a.t.Go(a.handleSignals)

        for _, w := range a.watchers </span><span class="cov0" title="0">{
                a.t.Go(w.Start)
        }</span>

        <span class="cov0" title="0">a.t.Go(a.serveMetrics)

        log.Debug().
                Int("pid", os.Getpid()).
                Str("name", release.NAME).
                Str("ver", release.VERSION).Msg("Starting wait")

        return a.t.Wait()</span>
}

// Stop cleans up and shuts down the Agent
func (a *Agent) Stop() <span class="cov1" title="1">{
        a.stopSignalHandler()

        for _, w := range a.watchers </span><span class="cov1" title="1">{
                w.Stop()
        }</span>

        <span class="cov1" title="1">a.svrHTTP.Close()

        log.Debug().
                Int("pid", os.Getpid()).
                Str("name", release.NAME).
                Str("ver", release.VERSION).Msg("Stopped")

        if a.t.Alive() </span><span class="cov1" title="1">{
                a.t.Kill(nil)
        }</span>
}

func (a *Agent) serveMetrics() error <span class="cov0" title="0">{
        log.Debug().Str("url", "http://"+a.svrHTTP.Addr+"/stats").Msg("app stats listener")
        if err := a.svrHTTP.ListenAndServe(); err != nil </span><span class="cov0" title="0">{
                if err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "HTTP server")
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// stopSignalHandler disables the signal handler
func (a *Agent) stopSignalHandler() <span class="cov1" title="1">{
        signal.Stop(a.signalCh)
        signal.Reset() // so a second ctrl-c will force a kill
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">// Copyright © 2017 Circonus, Inc. &lt;support@circonus.com&gt;
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
//

// +build freebsd openbsd solaris darwin

// Signal handling for FreeBSD, OpenBSD, Darwin, and Solaris
// systems that have SIGINFO

package agent

import (
        "fmt"
        "os"
        "os/signal"
        "runtime"

        "github.com/alecthomas/units"
        "github.com/rs/zerolog/log"
        "golang.org/x/sys/unix"
)

func (a *Agent) setupSignalHandler() <span class="cov10" title="2">{
        signal.Notify(a.signalCh, os.Interrupt, unix.SIGTERM, unix.SIGHUP, unix.SIGPIPE, unix.SIGINFO)
}</span>

// handleSignals runs the signal handler thread
func (a *Agent) handleSignals() error <span class="cov0" title="0">{
        const stacktraceBufSize = 1 * units.MiB

        // pre-allocate a buffer
        buf := make([]byte, stacktraceBufSize)

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-a.t.Dying():<span class="cov0" title="0">
                        return nil</span>
                case sig := &lt;-a.signalCh:<span class="cov0" title="0">
                        log.Info().Str("signal", sig.String()).Msg("Received signal")
                        switch sig </span>{
                        case os.Interrupt, unix.SIGTERM:<span class="cov0" title="0">
                                a.Stop()</span>
                        case unix.SIGPIPE, unix.SIGHUP:</span><span class="cov0" title="0">
                                // Noop
                        case unix.SIGINFO:<span class="cov0" title="0">
                                stacklen := runtime.Stack(buf, true)
                                fmt.Printf("=== received SIGINFO ===\n*** goroutine dump...\n%s\n*** end\n", buf[:stacklen])</span>
                        default:<span class="cov0" title="0">
                                log.Warn().Str("signal", sig.String()).Msg("unsupported")</span>
                        }
                }
        }
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Copyright © 2017 Circonus, Inc. &lt;support@circonus.com&gt;
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
//

package appstats

import (
        "expvar"
        "sync"

        "github.com/pkg/errors"
)

var (
        once              sync.Once
        stats             *expvar.Map
        notInitializedErr = errors.Errorf("stats not initialized")
)

func init() <span class="cov1" title="1">{
        once.Do(func() </span><span class="cov1" title="1">{
                stats = expvar.NewMap("stats")
        }</span>)
}

// NewString creates a new string stat
func NewString(name string) error <span class="cov7" title="3">{
        if stats == nil </span><span class="cov0" title="0">{
                return notInitializedErr
        }</span>

        <span class="cov7" title="3">if stats.Get(name) != nil </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov4" title="2">stats.Set(name, new(expvar.String))

        return nil</span>
}

// SetString sets string stat to value
func SetString(name string, value string) error <span class="cov4" title="2">{
        if stats == nil </span><span class="cov0" title="0">{
                return notInitializedErr
        }</span>

        <span class="cov4" title="2">if stats.Get(name) == nil </span><span class="cov1" title="1">{
                if err := NewString(name); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov4" title="2">stats.Get(name).(*expvar.String).Set(value)

        return nil</span>
}

// NewInt creates a new int stat
func NewInt(name string) error <span class="cov10" title="5">{
        if stats == nil </span><span class="cov0" title="0">{
                return notInitializedErr
        }</span>

        <span class="cov10" title="5">if stats.Get(name) != nil </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov8" title="4">stats.Set(name, new(expvar.Int))

        return nil</span>
}

// SetInt sets int stat to value
func SetInt(name string, value int64) error <span class="cov4" title="2">{
        if stats == nil </span><span class="cov0" title="0">{
                return notInitializedErr
        }</span>

        <span class="cov4" title="2">if stats.Get(name) == nil </span><span class="cov1" title="1">{
                if err := NewInt(name); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov4" title="2">stats.Get(name).(*expvar.Int).Set(value)

        return nil</span>
}

// IncrementInt increment int stat
func IncrementInt(name string) error <span class="cov4" title="2">{
        if stats == nil </span><span class="cov0" title="0">{
                return notInitializedErr
        }</span>

        <span class="cov4" title="2">if stats.Get(name) == nil </span><span class="cov1" title="1">{
                if err := NewInt(name); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov4" title="2">stats.Add(name, 1)

        return nil</span>
}

// DecrementInt decrement int stat
func DecrementInt(name string) error <span class="cov4" title="2">{
        if stats == nil </span><span class="cov0" title="0">{
                return notInitializedErr
        }</span>

        <span class="cov4" title="2">if stats.Get(name) == nil </span><span class="cov1" title="1">{
                if err := NewInt(name); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov4" title="2">stats.Add(name, -1)

        return nil</span>
}

// NewFloat creates a new float stat
func NewFloat(name string) error <span class="cov8" title="4">{
        if stats == nil </span><span class="cov0" title="0">{
                return notInitializedErr
        }</span>

        <span class="cov8" title="4">if stats.Get(name) != nil </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov7" title="3">stats.Set(name, new(expvar.Float))

        return nil</span>
}

// SetFloat sets a float stat to value
func SetFloat(name string, value float64) error <span class="cov4" title="2">{
        if stats == nil </span><span class="cov0" title="0">{
                return notInitializedErr
        }</span>

        <span class="cov4" title="2">if stats.Get(name) == nil </span><span class="cov1" title="1">{
                if err := NewFloat(name); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov4" title="2">stats.Get(name).(*expvar.Float).Set(value)

        return nil</span>
}

// AddFloat adds value to existing float
func AddFloat(name string, value float64) error <span class="cov4" title="2">{
        if stats == nil </span><span class="cov0" title="0">{
                return notInitializedErr
        }</span>

        <span class="cov4" title="2">if stats.Get(name) == nil </span><span class="cov1" title="1">{
                if err := NewFloat(name); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov4" title="2">stats.Get(name).(*expvar.Float).Add(value)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Copyright © 2017 Circonus, Inc. &lt;support@circonus.com&gt;
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
//

package defaults

import (
        "fmt"
        "os"
        "path/filepath"

        "github.com/circonus-labs/circonus-logwatch/internal/release"
)

const (
        // APIURL for circonus
        APIURL = "https://api.circonus.com/v2/"

        // APIApp defines the api app name associated with the api token key
        APIApp = release.NAME

        // Debug is false by default
        Debug = false

        // AppStatPort for accessing runtime metrics (expvar)
        AppStatPort = "33284"

        // LogLevel set to info by default
        LogLevel = "info"

        // LogPretty colored/formatted output to stderr
        LogPretty = false

        // DestinationType where metrics should be sent (agent|check|log|statsd)
        DestinationType = "log"

        // AgentPort for circonus-agent
        AgentPort = "2609"

        // StatsdPort for circonus-agent
        StatsdPort = "8125"

        // StatsdPrefix to prepend to every metric
        StatsdPrefix = "host."
)

var (
        // BasePath is the "base" directory
        //
        // expected installation structure:
        // base            (e.g. /opt/circonus/logwatch)
        //   /etc          (e.g. /opt/circonus/logwatch/etc)
        //   /etc/log.d    (e.g. /opt/circonus/logwatch/etc/log.d)
        //   /sbin         (e.g. /opt/circonus/logwatch/sbin)
        BasePath = ""

        // EtcPath returns the default etc directory within base directory
        EtcPath = "" // (e.g. /opt/circonus/logwatch/etc)

        // LogConfPath returns the default directory for log configurations within base directory
        LogConfPath = "" // (e.g. /opt/circonus/logwatch/etc/log.d)

        // Target used when destination type is "check"
        Target = ""
)

func init() <span class="cov8" title="1">{
        var exePath string
        var resolvedExePath string
        var err error

        exePath, err = os.Executable()
        if err == nil </span><span class="cov8" title="1">{
                resolvedExePath, err = filepath.EvalSymlinks(exePath)
                if err == nil </span><span class="cov8" title="1">{
                        BasePath = filepath.Clean(filepath.Join(filepath.Dir(resolvedExePath), "..")) // e.g. /opt/circonus/agent
                }</span>
        }

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Unable to determine path to binary %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov8" title="1">EtcPath = filepath.Join(BasePath, "etc")
        LogConfPath = filepath.Join(EtcPath, "log.d")

        Target, err = os.Hostname()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Unable to determine hostname for target %v\n", err)
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Copyright © 2017 Circonus, Inc. &lt;support@circonus.com&gt;
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
//

package config

import (
        "encoding/json"
        "expvar"
        "fmt"
        "io"
        "io/ioutil"
        "net"
        "net/url"
        "os"
        "path/filepath"
        "strings"

        "github.com/circonus-labs/circonus-logwatch/internal/config/defaults"
        "github.com/circonus-labs/circonus-logwatch/internal/release"
        toml "github.com/pelletier/go-toml"
        "github.com/pkg/errors"
        "github.com/rs/zerolog/log"
        "github.com/spf13/viper"
        yaml "gopkg.in/yaml.v2"
)

// Validate the configuration options supplied
func Validate() error <span class="cov7" title="7">{

        if err := logConfDir(); err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov7" title="6">if err := destConf(); err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov6" title="5">if viper.GetString(KeyDestType) == "check" </span><span class="cov3" title="2">{
                if err := apiConf(); err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>
        }

        <span class="cov5" title="4">return nil</span>
}

func destConf() error <span class="cov10" title="14">{
        dest := viper.GetString(KeyDestType)
        switch dest </span>{
        case "log":<span class="cov3" title="2">
                return nil</span> // nothing to validate

        case "check":<span class="cov4" title="3">
                return nil</span> // cgm will vet the config

        case "statsd":<span class="cov4" title="3">
                id := viper.GetString(KeyDestCfgID)
                if id == "" </span><span class="cov4" title="3">{
                        viper.Set(KeyDestCfgID, release.NAME)
                }</span>
                <span class="cov4" title="3">port := viper.GetString(KeyDestCfgPort)
                if port == "" </span><span class="cov3" title="2">{
                        port = defaults.StatsdPort
                        viper.Set(KeyDestCfgPort, port)
                }</span>

                <span class="cov4" title="3">addr := net.JoinHostPort("localhost", port)
                a, err := net.ResolveUDPAddr("udp", addr)
                if err != nil </span><span class="cov1" title="1">{
                        return errors.Wrapf(err, "destination %s, port %s", dest, addr)
                }</span>

                <span class="cov3" title="2">if err := testPort("udp", a.String()); err != nil </span><span class="cov0" title="0">{
                        return errors.Wrapf(err, "destination %s, port %s", dest, addr)
                }</span>

        case "agent":<span class="cov5" title="4">
                id := viper.GetString(KeyDestCfgID)
                if id == "" </span><span class="cov5" title="4">{
                        viper.Set(KeyDestCfgID, release.NAME)
                }</span>
                <span class="cov5" title="4">port := viper.GetString(KeyDestCfgPort)
                if port == "" </span><span class="cov4" title="3">{
                        port = defaults.AgentPort
                        viper.Set(KeyDestCfgPort, port)
                }</span>

                <span class="cov5" title="4">addr := net.JoinHostPort("localhost", port)
                a, err := net.ResolveTCPAddr("tcp", addr)
                if err != nil </span><span class="cov1" title="1">{
                        return errors.Wrapf(err, "destination %s, port %s", dest, addr)
                }</span>

                <span class="cov4" title="3">if err := testPort("tcp", a.String()); err != nil </span><span class="cov1" title="1">{
                        return errors.Wrapf(err, "destination %s, port %s", dest, addr)
                }</span>

                <span class="cov3" title="2">viper.Set(KeyDestAgentURL, fmt.Sprintf("http://%s/write/%s", a.String(), id))</span>

        default:<span class="cov3" title="2">
                return errors.Errorf("invalid/unknown metric destination (%s)", dest)</span>
        }

        <span class="cov5" title="4">return nil</span>
}

func apiConf() error <span class="cov8" title="9">{
        apiKey := viper.GetString(KeyAPITokenKey)
        apiApp := viper.GetString(KeyAPITokenApp)
        apiURL := viper.GetString(KeyAPIURL)

        // if key is 'cosi' - load the cosi api config
        if strings.ToLower(apiKey) == cosiName </span><span class="cov1" title="1">{
                cKey, cApp, cURL, err := loadCOSIConfig()
                if err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>

                <span class="cov0" title="0">apiKey = cKey
                apiApp = cApp
                apiURL = cURL</span>
        }

        // API is required for reverse and/or statsd

        <span class="cov8" title="8">if apiKey == "" </span><span class="cov3" title="2">{
                return errors.New("API key is required")
        }</span>

        <span class="cov7" title="6">if apiApp == "" </span><span class="cov1" title="1">{
                return errors.New("API app is required")
        }</span>

        <span class="cov6" title="5">if apiURL == "" </span><span class="cov1" title="1">{
                return errors.New("API URL is required")
        }</span>

        <span class="cov5" title="4">if apiURL != defaults.APIURL </span><span class="cov4" title="3">{
                parsedURL, err := url.Parse(apiURL)
                if err != nil </span><span class="cov1" title="1">{
                        return errors.Wrap(err, "Invalid API URL")
                }</span>
                <span class="cov3" title="2">if parsedURL.Scheme == "" || parsedURL.Host == "" || parsedURL.Path == "" </span><span class="cov1" title="1">{
                        return errors.Errorf("Invalid API URL (%s)", apiURL)
                }</span>
        }

        <span class="cov3" title="2">viper.Set(KeyAPITokenKey, apiKey)
        viper.Set(KeyAPITokenApp, apiApp)
        viper.Set(KeyAPIURL, apiURL)

        return nil</span>
}

type cosiConfig struct {
        APIKey string `json:"api_key"`
        APIApp string `json:"api_app"`
        APIURL string `json:"api_url"`
}

func loadCOSIConfig() (string, string, string, error) <span class="cov7" title="6">{
        data, err := ioutil.ReadFile(cosiCfgFile)
        if err != nil </span><span class="cov3" title="2">{
                return "", "", "", errors.Wrap(err, "Unable to access cosi config")
        }</span>

        <span class="cov5" title="4">var cfg cosiConfig
        if err := json.Unmarshal(data, &amp;cfg); err != nil </span><span class="cov1" title="1">{
                return "", "", "", errors.Wrapf(err, "Unable to parse cosi config (%s)", cosiCfgFile)
        }</span>

        <span class="cov4" title="3">if cfg.APIKey == "" </span><span class="cov1" title="1">{
                return "", "", "", errors.Errorf("Missing API key, invalid cosi config (%s)", cosiCfgFile)
        }</span>
        <span class="cov3" title="2">if cfg.APIApp == "" </span><span class="cov1" title="1">{
                return "", "", "", errors.Errorf("Missing API app, invalid cosi config (%s)", cosiCfgFile)
        }</span>
        <span class="cov1" title="1">if cfg.APIURL == "" </span><span class="cov1" title="1">{
                return "", "", "", errors.Errorf("Missing API URL, invalid cosi config (%s)", cosiCfgFile)
        }</span>

        <span class="cov0" title="0">return cfg.APIKey, cfg.APIApp, cfg.APIURL, nil</span>

}

func logConfDir() error <span class="cov9" title="13">{
        errMsg := "Invalid log configuration directory"
        dir := viper.GetString(KeyLogConfDir)

        if dir == "" </span><span class="cov3" title="2">{
                return errors.Errorf(errMsg+" (%s)", dir)
        }</span>

        <span class="cov9" title="11">absDir, err := filepath.Abs(dir)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, errMsg)
        }</span>

        <span class="cov9" title="11">dir = absDir

        fi, err := os.Stat(dir)
        if err != nil </span><span class="cov3" title="2">{
                return errors.Wrap(err, errMsg)
        }</span>

        <span class="cov8" title="9">if !fi.Mode().IsDir() </span><span class="cov1" title="1">{
                return errors.Errorf(errMsg+" (%s) not a directory", dir)
        }</span>

        // also try opening, to verify permissions
        // if last dir on path is not accessible to user, stat doesn't return EPERM
        <span class="cov8" title="8">f, err := os.Open(dir)
        if err != nil </span><span class="cov1" title="1">{
                return errors.Wrap(err, errMsg)
        }</span>
        <span class="cov7" title="7">f.Close()

        viper.Set(KeyLogConfDir, dir)

        return nil</span>
}

// testPort is used to verify agent|statsd port
func testPort(network, address string) error <span class="cov6" title="5">{
        c, err := net.Dial(network, address)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov5" title="4">return c.Close()</span>
}

// StatConfig adds the running config to the app stats
func StatConfig() error <span class="cov1" title="1">{
        cfg, err := getConfig()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">cfg.API.Key = "..."
        cfg.API.App = "..."

        expvar.Publish("config", expvar.Func(func() interface{} </span><span class="cov0" title="0">{
                return &amp;cfg
        }</span>))

        <span class="cov1" title="1">return nil</span>
}

// getConfig dumps the current configuration and returns it
func getConfig() (*Config, error) <span class="cov7" title="6">{
        var cfg *Config

        if err := viper.Unmarshal(&amp;cfg); err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "parsing config")
        }</span>

        <span class="cov7" title="6">return cfg, nil</span>
}

// ShowConfig prints the running configuration
func ShowConfig(w io.Writer) error <span class="cov5" title="4">{
        var cfg *Config
        var err error
        var data []byte

        cfg, err = getConfig()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov5" title="4">format := viper.GetString(KeyShowConfig)

        log.Debug().Str("format", format).Msg("show-config")

        switch format </span>{
        case "json":<span class="cov1" title="1">
                data, err = json.MarshalIndent(cfg, " ", "  ")
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "formatting config (json)")
                }</span>
        case "yaml":<span class="cov1" title="1">
                data, err = yaml.Marshal(cfg)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "formatting config (yaml)")
                }</span>
        case "toml":<span class="cov1" title="1">
                data, err = toml.Marshal(*cfg)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "formatting config (toml)")
                }</span>
        default:<span class="cov1" title="1">
                return errors.Errorf("unknown config format '%s'", format)</span>
        }

        <span class="cov4" title="3">fmt.Fprintf(w, "%s v%s running config:\n%s\n", release.NAME, release.VERSION, data)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Copyright © 2017 Circonus, Inc. &lt;support@circonus.com&gt;
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
//

package configs

import (
        "encoding/json"
        "fmt"
        "io/ioutil"
        "os"
        "path"
        "path/filepath"
        "regexp"
        "strings"
        "text/template"

        "github.com/circonus-labs/circonus-logwatch/internal/config"
        "github.com/pelletier/go-toml"
        "github.com/pkg/errors"
        "github.com/rs/zerolog"
        "github.com/rs/zerolog/log"
        "github.com/spf13/viper"
        "gopkg.in/yaml.v2"
)

// Load reads the log configurations from log config directory
func Load() ([]*Config, error) <span class="cov4" title="3">{
        logger := log.With().Str("pkg", "configs").Logger()
        supportedConfExts := regexp.MustCompile(`^\.(yaml|json|toml)$`)
        logConfDir := viper.GetString(config.KeyLogConfDir)

        if logConfDir == "" </span><span class="cov1" title="1">{
                return nil, errors.Errorf("invalid log config directory (empty)")
        }</span>

        <span class="cov3" title="2">logger.Debug().
                Str("dir", logConfDir).
                Msg("loading log configs")

        entries, err := ioutil.ReadDir(logConfDir)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov3" title="2">if len(entries) == 0 </span><span class="cov1" title="1">{
                return nil, errors.Errorf("no log configurations found in (%s)", logConfDir)
        }</span>

        <span class="cov1" title="1">var cfgs []*Config

        for _, entry := range entries </span><span class="cov10" title="12">{
                if entry.IsDir() </span><span class="cov1" title="1">{
                        continue</span>
                }

                <span class="cov9" title="11">cfgFile := path.Join(logConfDir, entry.Name())
                cfgType := filepath.Ext(cfgFile)
                if !supportedConfExts.MatchString(cfgType) </span><span class="cov1" title="1">{
                        logger.Warn().
                                Str("type", cfgType).
                                Str("file", cfgFile).
                                Msg("unsupported config type, ignoring")
                        continue</span>
                }

                <span class="cov9" title="10">logger.Debug().
                        Str("type", cfgType).
                        Str("file", cfgFile).
                        Msg("loading")
                logcfg, err := parse(cfgType, cfgFile)
                if err != nil </span><span class="cov4" title="3">{
                        logger.Warn().
                                Err(err).
                                Str("file", cfgFile).
                                Msg("parsing")
                        continue</span>
                }

                <span class="cov8" title="7">if err := checkLogFileAccess(logcfg.LogFile); err != nil </span><span class="cov4" title="3">{
                        logger.Warn().
                                Err(err).
                                Str("log", logcfg.LogFile).
                                Msg("access")
                        continue</span>
                }

                <span class="cov6" title="4">if logcfg.ID == "" </span><span class="cov6" title="4">{ // ID not explicitly set, use the base of the config file name
                        logcfg.ID = strings.Replace(filepath.Base(logcfg.LogFile), filepath.Ext(logcfg.LogFile), "", -1)
                }</span>

                <span class="cov6" title="4">if validMetricRules(logcfg.ID, logger, logcfg.Metrics) </span><span class="cov1" title="1">{
                        cfgs = append(cfgs, &amp;logcfg)
                }</span>
        }

        <span class="cov1" title="1">return cfgs, nil</span>
}

func validMetricRules(logID string, logger zerolog.Logger, rules []*Metric) bool <span class="cov6" title="4">{
        for ruleID, rule := range rules </span><span class="cov6" title="5">{
                if rule.Match == "" </span><span class="cov1" title="1">{
                        logger.Warn().
                                Str("log_id", logID).
                                Int("rule_id", ruleID).
                                Msg("invalid metric rule, empty 'match', skipping config")
                        return false
                }</span>

                <span class="cov6" title="4">if rule.Name == "" </span><span class="cov1" title="1">{
                        logger.Warn().
                                Str("log_id", logID).
                                Int("rule_id", ruleID).
                                Msg("invalid metric rule, empty 'name', skipping config")
                        return false
                }</span>

                <span class="cov4" title="3">matcher, err := regexp.Compile(rule.Match)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Warn().
                                Err(err).
                                Str("log_id", logID).
                                Int("rule_id", ruleID).
                                Str("match", rule.Match).
                                Msg("rule match compile failed, skipping config")
                        return false
                }</span>
                <span class="cov4" title="3">if matcher == nil </span><span class="cov0" title="0">{
                        logger.Warn().
                                Str("log_id", logID).
                                Int("rule_id", ruleID).
                                Str("match", rule.Match).
                                Msg("rule match compile resulted in nil value, skipping config")
                        return false
                }</span>
                <span class="cov4" title="3">rule.Matcher = matcher
                rule.MatchParts = matcher.SubexpNames()

                if len(rule.MatchParts) &lt; 2 </span><span class="cov3" title="2">{
                        logger.Warn().
                                Str("log_id", logID).
                                Int("rule_id", ruleID).
                                Msg("forcing type to counter, no named subexpressions found")
                        rule.Type = "c"
                }</span><span class="cov1" title="1"> else {
                        // find the 'Value' subexpression and save its index for extraction on matched lines
                        for _, subName := range rule.MatchParts </span><span class="cov4" title="3">{
                                if strings.ToLower(subName) == "value" </span><span class="cov1" title="1">{
                                        rule.ValueKey = subName
                                        break</span> // there can be only one
                                }
                        }

                        <span class="cov1" title="1">if rule.ValueKey == "" </span><span class="cov0" title="0">{
                                logger.Warn().
                                        Str("log_id", logID).
                                        Int("id_id", ruleID).
                                        Msg("forcing type to counter, no subexpression named 'Value' found")
                                rule.Type = "c"
                        }</span>
                }

                // template does not contain template interpolation code, treat it as a literal metric name
                <span class="cov4" title="3">if !strings.Contains(rule.Name, "{{.") </span><span class="cov1" title="1">{
                        continue</span>
                }

                <span class="cov3" title="2">if len(rule.MatchParts) &lt; 2 </span><span class="cov1" title="1">{
                        logger.Warn().
                                Str("log_id", logID).
                                Int("id_id", ruleID).
                                Str("match", rule.Match).
                                Str("name", rule.Name).
                                Msg("'name' expects matches, match has no named subexpressions, skipping config")
                        return false
                }</span>

                <span class="cov1" title="1">templateID := fmt.Sprintf("%s:M%d", logID, ruleID)
                namer, err := template.New(templateID).Parse(rule.Name)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Warn().
                                Err(err).
                                Str("log_id", logID).
                                Int("id_id", ruleID).
                                Str("name", rule.Name).
                                Msg("name template parse failed, skipping config")
                        return false
                }</span>
                <span class="cov1" title="1">if namer == nil </span><span class="cov0" title="0">{
                        logger.Warn().
                                Str("log_id", logID).
                                Int("id_id", ruleID).
                                Str("name", rule.Name).
                                Msg("name template parse resulted in nil value, skipping config")
                        return false
                }</span>
                <span class="cov1" title="1">rule.Namer = namer</span>
        }

        <span class="cov1" title="1">return true</span>
}

// parse reads and parses a log configuration
func parse(cfgType, cfgFile string) (Config, error) <span class="cov9" title="10">{
        var cfg Config

        data, err := ioutil.ReadFile(cfgFile)
        if err != nil </span><span class="cov0" title="0">{
                return cfg, err
        }</span>

        <span class="cov9" title="10">switch cfgType </span>{
        case ".json":<span class="cov3" title="2">
                err := json.Unmarshal(data, &amp;cfg)
                if serr, ok := err.(*json.SyntaxError); ok </span><span class="cov1" title="1">{
                        line, col := findLine(data, serr.Offset)
                        return cfg, errors.Wrapf(err, "line %d, col %d", line, col)
                }</span>
                <span class="cov1" title="1">return cfg, err</span>
        case ".yaml":<span class="cov7" title="6">
                err := yaml.Unmarshal(data, &amp;cfg)
                if err != nil </span><span class="cov1" title="1">{
                        return cfg, err
                }</span>
        case ".toml":<span class="cov3" title="2">
                err := toml.Unmarshal(data, &amp;cfg)
                if err != nil </span><span class="cov1" title="1">{
                        return cfg, err
                }</span>
        default:<span class="cov0" title="0">
                return cfg, errors.Errorf("unknown config type (%s)", cfgType)</span>
        }

        <span class="cov7" title="6">return cfg, nil</span>
}

// checkLogFileAccess verifies a log file can be opened for reading
func checkLogFileAccess(file string) error <span class="cov8" title="7">{
        f, err := os.Open(file)
        if err != nil </span><span class="cov4" title="3">{
                return err
        }</span>
        <span class="cov6" title="4">f.Close()
        return nil</span>
}

func findLine(data []byte, offset int64) (int, int) <span class="cov1" title="1">{
        if offset == 0 </span><span class="cov0" title="0">{
                return 1, 1
        }</span>
        <span class="cov1" title="1">const (
                CR = 13
                LF = 10
        )
        line := 1
        col := 0
        for i := int64(0); i &lt; offset; i++ </span><span class="cov10" title="12">{
                col++
                if data[i] == CR || data[i] == LF </span><span class="cov1" title="1">{
                        col = 0
                        line++
                }</span>
        }
        <span class="cov1" title="1">return line, col</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Copyright © 2017 Circonus, Inc. &lt;support@circonus.com&gt;
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
//

package circonus

import (
        "fmt"
        stdlog "log"

        cgm "github.com/circonus-labs/circonus-gometrics"
        "github.com/circonus-labs/circonus-logwatch/internal/config"
        "github.com/pkg/errors"
        "github.com/rs/zerolog/log"
        "github.com/spf13/viper"
)

// New returns a new instance of the circonus metrics destination
func New() (*Circonus, error) <span class="cov10" title="22">{
        var client *cgm.CirconusMetrics

        logger := log.With().Str("pkg", "circonus").Logger()
        dest := viper.GetString(config.KeyDestType)

        switch dest </span>{
        case "agent":<span class="cov7" title="11">
                sURL := viper.GetString(config.KeyDestAgentURL)
                if sURL == "" </span><span class="cov1" title="1">{
                        return nil, errors.Errorf("invalid agent url defined (empty)")
                }</span>
                <span class="cov7" title="10">cmc := &amp;cgm.Config{
                        Debug: viper.GetBool(config.KeyDebugCGM),
                        Log:   stdlog.New(log.With().Str("pkg", "dest-agent").Logger(), "", 0),
                }
                cmc.Interval = "60s"
                cmc.CheckManager.Check.SubmissionURL = sURL
                c, err := cgm.New(cmc)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "creating client for destination 'agent'")
                }</span>
                <span class="cov7" title="10">client = c</span>

        case "check":<span class="cov7" title="10">
                cmc := &amp;cgm.Config{
                        Debug: viper.GetBool(config.KeyDebugCGM),
                        Log:   stdlog.New(log.With().Str("pkg", "dest-check").Logger(), "", 0),
                }
                cmc.CheckManager.Check.ID = viper.GetString(config.KeyDestCfgCID)
                cmc.CheckManager.Check.SubmissionURL = viper.GetString(config.KeyDestCfgURL)
                cmc.CheckManager.Check.SearchTag = viper.GetString(config.KeyDestCfgSearchTag)
                cmc.CheckManager.Check.TargetHost = viper.GetString(config.KeyDestCfgTarget)
                c, err := cgm.New(cmc)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "creating client for destination 'check'")
                }</span>
                <span class="cov7" title="10">client = c</span>

        default:<span class="cov1" title="1">
                return nil, errors.Errorf("unknown destination type for circonus client %s", dest)</span>
        }

        <span class="cov9" title="20">return &amp;Circonus{client: client, logger: logger}, nil</span>
}

// Start NOOP cgm starts as it is initialized
func (c *Circonus) Start() error <span class="cov9" title="18">{
        // noop
        return nil
}</span>

// Stop flushes any outstanding metrics
func (c *Circonus) Stop() error <span class="cov9" title="16">{
        c.client.Flush()
        return nil
}</span>

// SetGaugeValue sends a gauge metric
func (c *Circonus) SetGaugeValue(metric string, value interface{}) error <span class="cov3" title="2">{ // gauge (ints or floats)
        c.client.Gauge(metric, value)
        return nil
}</span>

// SetTimingValue sends a timing metric
func (c *Circonus) SetTimingValue(metric string, value float64) error <span class="cov3" title="2">{ // histogram
        return c.SetHistogramValue(metric, value)
}</span>

// SetHistogramValue sends a histogram metric
func (c *Circonus) SetHistogramValue(metric string, value float64) error <span class="cov5" title="4">{ // histogram
        c.client.RecordValue(metric, value)
        return nil
}</span>

// IncrementCounter sends a counter increment
func (c *Circonus) IncrementCounter(metric string) error <span class="cov5" title="4">{ // counter (monotonically increasing value)
        return c.IncrementCounterByValue(metric, 1)
}</span>

// IncrementCounterByValue sends value to add to counter
func (c *Circonus) IncrementCounterByValue(metric string, value uint64) error <span class="cov6" title="6">{ // counter (monotonically increasing value)
        c.client.IncrementByValue(metric, value)
        return nil
}</span>

// AddSetValue sends a unique value to the set metric
func (c *Circonus) AddSetValue(metric string, value string) error <span class="cov3" title="2">{ // set metric (ala statsd, counts unique values)
        c.IncrementCounter(fmt.Sprintf("%s`%s", metric, value))
        return nil
}</span>

// SetTextValue sends a text metric
func (c *Circonus) SetTextValue(metric string, value string) error <span class="cov3" title="2">{ // text metric
        c.client.SetTextValue(metric, value)
        return nil
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">// Copyright © 2017 Circonus, Inc. &lt;support@circonus.com&gt;
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
//

package logonly

import (
        "github.com/rs/zerolog/log"
)

// New creates a new log only destination
func New() (*LogOnly, error) <span class="cov10" title="10">{

        once.Do(func() </span><span class="cov1" title="1">{
                client = &amp;LogOnly{
                        logger: log.With().Str("pkg", "dest-log").Logger(),
                }
        }</span>)

        <span class="cov10" title="10">return client, nil</span>
}

// Start is a NOP for log only destination
func (c *LogOnly) Start() error <span class="cov9" title="9">{
        // NOP
        return nil
}</span>

// Stop is a NOP for log only destination
func (c *LogOnly) Stop() error <span class="cov9" title="8">{
        // NOP
        return nil
}</span>

// IncrementCounter increments a counter - type 'c'
func (c *LogOnly) IncrementCounter(metric string) error <span class="cov1" title="1">{ // counter (monotonically increasing value)
        c.logger.Info().Str("name", metric).Interface("value", 1).Msg("metric")
        return nil
}</span>

// IncrementCounterByValue sends value to add to counter - type 'c'
func (c *LogOnly) IncrementCounterByValue(metric string, value uint64) error <span class="cov1" title="1">{ // counter (monotonically increasing value)
        c.logger.Info().Str("name", metric).Interface("value", value).Msg("metric")
        return nil
}</span>

// SetGaugeValue sets a gauge metric to the specified value - type 'g'
func (c *LogOnly) SetGaugeValue(metric string, value interface{}) error <span class="cov1" title="1">{ // gauge (ints or floats)
        c.logger.Info().Str("name", metric).Interface("value", value).Msg("metric")
        return nil
}</span>

// SetHistogramValue sets a histogram metric to the specified value - type 'h'
func (c *LogOnly) SetHistogramValue(metric string, value float64) error <span class="cov1" title="1">{ // histogram
        c.logger.Info().Str("name", metric).Interface("value", value).Msg("metric")
        return nil
}</span>

// SetTimingValue sets a timing metric to the specified value - type 'ms'
func (c *LogOnly) SetTimingValue(metric string, value float64) error <span class="cov1" title="1">{ // histogram
        c.logger.Info().Str("name", metric).Interface("value", value).Msg("metric")
        return nil
}</span>

// AddSetValue adds (or increments the counter) for the specified unique value - type 's'
func (c *LogOnly) AddSetValue(metric, value string) error <span class="cov1" title="1">{ // set metric (ala statsd, counts unique values)
        c.logger.Info().Str("name", metric).Interface("value", value).Msg("metric")
        return nil
}</span>

// SetTextValue sets a text metric to the specified value - type 't'
func (c *LogOnly) SetTextValue(metric, value string) error <span class="cov1" title="1">{ // text metric
        c.logger.Info().Str("name", metric).Interface("value", value).Msg("metric")
        return nil
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">// Copyright © 2017 Circonus, Inc. &lt;support@circonus.com&gt;
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
//

package statsd

import (
        crand "crypto/rand"
        "fmt"
        "math"
        "math/big"
        "math/rand"
        "net"
        "time"

        "github.com/circonus-labs/circonus-logwatch/internal/config"
        "github.com/pkg/errors"
        "github.com/rs/zerolog/log"
        "github.com/spf13/viper"
)

func init() <span class="cov1" title="1">{
        n, err := crand.Int(crand.Reader, big.NewInt(math.MaxInt64))
        if err != nil </span><span class="cov0" title="0">{
                rand.Seed(time.Now().UTC().UnixNano())
                return
        }</span>
        <span class="cov1" title="1">rand.Seed(n.Int64())</span>
}

// New initializes a udp connection to the localhost
func New() (*Statsd, error) <span class="cov9" title="12">{
        id := viper.GetString(config.KeyDestCfgID)
        if id == "" </span><span class="cov1" title="1">{
                return nil, errors.Errorf("invalid id, empty")
        }</span>

        <span class="cov9" title="11">port := viper.GetString(config.KeyDestCfgPort)
        if port == "" </span><span class="cov1" title="1">{
                return nil, errors.Errorf("invalid port, empty")
        }</span>

        <span class="cov8" title="10">once.Do(func() </span><span class="cov1" title="1">{
                client = &amp;Statsd{
                        id:     id,
                        port:   port,
                        prefix: viper.GetString(config.KeyDestCfgStatsdPrefix) + id,
                        logger: log.With().Str("pkg", "dest-statsd").Logger(),
                }
        }</span>)

        <span class="cov8" title="10">return client, nil</span>
}

// Start the statsd Statsd
func (c *Statsd) Start() error <span class="cov8" title="9">{
        return c.open()
}</span>

// Stop the statsd Statsd
func (c *Statsd) Stop() error <span class="cov8" title="8">{
        if c.conn == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="8">return c.conn.Close()</span>
}

// SetGaugeValue sends a gauge metric
func (c *Statsd) SetGaugeValue(metric string, value interface{}) error <span class="cov1" title="1">{ // gauge (ints or floats)
        v, err := getGaugeValue(value)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">return c.send(fmt.Sprintf("%s:%s|g", metric, v))</span>
}

// SetTimingValue sends a timing metric
func (c *Statsd) SetTimingValue(metric string, value float64) error <span class="cov1" title="1">{ // histogram
        return c.SetHistogramValue(metric, value)
}</span>

// SetHistogramValue sends a histogram metric
func (c *Statsd) SetHistogramValue(metric string, value float64) error <span class="cov3" title="2">{ // histogram
        return c.send(fmt.Sprintf("%s:%e|ms", metric, value))
}</span>

// IncrementCounter sends a counter increment
func (c *Statsd) IncrementCounter(metric string) error <span class="cov1" title="1">{ // counter (monotonically increasing value)
        return c.IncrementCounterByValue(metric, 1)
}</span>

// IncrementCounterByValue sends value to add to counter
func (c *Statsd) IncrementCounterByValue(metric string, value uint64) error <span class="cov3" title="2">{ // counter (monotonically increasing value)
        return c.send(fmt.Sprintf("%s:%d|c", metric, value))
}</span>

// AddSetValue sends a unique value to the set metric
func (c *Statsd) AddSetValue(metric string, value string) error <span class="cov1" title="1">{ // set metric (ala statsd, counts unique values)
        return c.send(fmt.Sprintf("%s:%s|s", metric, value))
}</span>

// SetTextValue sends a text metric
func (c *Statsd) SetTextValue(metric string, value string) error <span class="cov1" title="1">{ // text metric
        return c.send(fmt.Sprintf("%s:%s|t", metric, value))
}</span>

// send stats data to udp statsd daemon
//
// Outgoing metric format:
//
//   name:value|type[@rate]
//
// e.g.
//   foo:1|c
//   foo:1|c@0.5
//   bar:2.5|ms
//   bar:2.5|ms@.25
//   baz:25|g
//   qux:abcd123|s
//   dib:38.282|h
//   dab:yadda yadda yadda|t
func (c *Statsd) send(metric string) error <span class="cov7" title="7">{
        if c.conn == nil </span><span class="cov0" title="0">{
                if err := c.open(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov7" title="7">m := c.prefix + metric

        c.logger.Debug().Str("metric", m).Msg("sending")

        _, err := fmt.Fprintf(c.conn, m)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="7">return nil</span>
}

// open udp connection
func (c *Statsd) open() error <span class="cov8" title="9">{
        if c.conn != nil </span><span class="cov8" title="8">{
                c.conn.Close()
        }</span>

        <span class="cov8" title="9">conn, err := net.Dial("udp", net.JoinHostPort("", c.port))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="9">c.conn = conn

        return nil</span>
}

// getGaugeValue as string from interface
func getGaugeValue(value interface{}) (string, error) <span class="cov10" title="14">{
        vs := ""
        switch v := value.(type) </span>{
        case int:<span class="cov3" title="2">
                vs = fmt.Sprintf("%d", v)</span>
        case int8:<span class="cov1" title="1">
                vs = fmt.Sprintf("%d", v)</span>
        case int16:<span class="cov1" title="1">
                vs = fmt.Sprintf("%d", v)</span>
        case int32:<span class="cov1" title="1">
                vs = fmt.Sprintf("%d", v)</span>
        case int64:<span class="cov1" title="1">
                vs = fmt.Sprintf("%d", v)</span>
        case uint:<span class="cov1" title="1">
                vs = fmt.Sprintf("%d", v)</span>
        case uint8:<span class="cov1" title="1">
                vs = fmt.Sprintf("%d", v)</span>
        case uint16:<span class="cov1" title="1">
                vs = fmt.Sprintf("%d", v)</span>
        case uint32:<span class="cov1" title="1">
                vs = fmt.Sprintf("%d", v)</span>
        case uint64:<span class="cov1" title="1">
                vs = fmt.Sprintf("%d", v)</span>
        case float32:<span class="cov1" title="1">
                vs = fmt.Sprintf("%f", v)</span>
        case float64:<span class="cov1" title="1">
                vs = fmt.Sprintf("%f", v)</span>
        default:<span class="cov1" title="1">
                return "", errors.Errorf("unknown type for value %v", v)</span>
        }
        <span class="cov9" title="13">return vs, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Copyright © 2017 Circonus, Inc. &lt;support@circonus.com&gt;
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
//

package release

import (
        "expvar"
)

func init() <span class="cov8" title="1">{
        expvar.Publish("app", expvar.Func(info))
}</span>

func info() interface{} <span class="cov8" title="1">{
        return &amp;Info{
                Name:      NAME,
                Version:   VERSION,
                Commit:    COMMIT,
                BuildDate: DATE,
                Tag:       TAG,
        }
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">// Copyright © 2017 Circonus, Inc. &lt;support@circonus.com&gt;
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
//

package watcher

import (
        "bytes"
        "fmt"
        "io"
        "io/ioutil"
        stdlog "log"
        "strconv"
        "strings"
        "time"

        "github.com/circonus-labs/circonus-logwatch/internal/appstats"
        "github.com/circonus-labs/circonus-logwatch/internal/config"
        "github.com/circonus-labs/circonus-logwatch/internal/configs"
        "github.com/circonus-labs/circonus-logwatch/internal/metrics"
        "github.com/hpcloud/tail"
        "github.com/pkg/errors"
        "github.com/rs/zerolog/log"
        "github.com/spf13/viper"
)

// New creates a new watcher instance
func New(metricDest metrics.Destination, logConfig *configs.Config) (*Watcher, error) <span class="cov4" title="7">{
        if metricDest == nil </span><span class="cov2" title="2">{
                return nil, errors.New("invalid metric destination (nil)")
        }</span>
        <span class="cov4" title="5">if logConfig == nil </span><span class="cov1" title="1">{
                return nil, errors.New("invalid log config (nil)")
        }</span>

        <span class="cov3" title="4">w := Watcher{
                logger:           log.With().Str("pkg", "watcher").Str("log_id", logConfig.ID).Logger(),
                cfg:              logConfig,
                dest:             metricDest,
                metricLines:      make(chan metricLine, metricLineQueueSize),
                metrics:          make(chan metric, metricQueueSize),
                trace:            viper.GetBool(config.KeyDebugMetric),
                statMatchedLines: logConfig.ID + "_lines_matched",
                statTotalLines:   logConfig.ID + "_lines_total",
        }

        appstats.NewInt(w.statMatchedLines)
        appstats.NewInt(w.statTotalLines)

        return &amp;w, nil</span>
}

// Start the watcher
func (w *Watcher) Start() error <span class="cov3" title="3">{
        w.t.Go(w.save)
        w.t.Go(w.parse)
        w.t.Go(w.process)
        return w.t.Wait()
}</span>

// Stop the watcher
func (w *Watcher) Stop() error <span class="cov3" title="3">{
        w.logger.Info().Msg("stopping")
        if w.t.Alive() </span><span class="cov3" title="3">{
                w.t.Kill(nil)
        }</span>

        <span class="cov3" title="3">return nil</span>
}

// process opens log and checks log lines for matches
func (w *Watcher) process() error <span class="cov3" title="3">{
        cfg := tail.Config{
                Follow:    true,
                ReOpen:    true,
                MustExist: true,
                Location: &amp;tail.SeekInfo{
                        Offset: 0,
                        Whence: io.SeekEnd,
                },
                Logger: stdlog.New(ioutil.Discard, "", 0),
        }

        if viper.GetBool(config.KeyDebugTail) </span><span class="cov0" title="0">{
                cfg.Logger = stdlog.New(w.logger.With().Str("pkg", "tail").Logger(), "", 0)
        }</span>

        <span class="cov3" title="3">tailer, err := tail.TailFile(w.cfg.LogFile, cfg)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov3" title="3">for </span><span class="cov6" title="12">{
                select </span>{
                case &lt;-w.t.Dying():<span class="cov3" title="3">
                        tailer.Cleanup()
                        return nil</span>
                case &lt;-tailer.Dying():<span class="cov0" title="0">
                        tailer.Cleanup()
                        return nil</span>
                case line := &lt;-tailer.Lines:<span class="cov5" title="9">
                        if line == nil </span><span class="cov0" title="0">{
                                _, err := tailer.Tell()
                                if err != nil </span><span class="cov0" title="0">{
                                        if !strings.Contains(err.Error(), "file already closed") </span><span class="cov0" title="0">{
                                                tailer.Cleanup()
                                                return err
                                        }</span>
                                }
                                <span class="cov0" title="0">w.logger.Warn().Msg("nil line, stopping tail")
                                tailer.Cleanup()
                                return nil</span>
                        }
                        <span class="cov5" title="9">if line.Err != nil </span><span class="cov0" title="0">{
                                w.logger.Error().
                                        Err(line.Err).
                                        Str("log_line", line.Text).
                                        Msg("tail")
                                tailer.Cleanup()
                                return err
                        }</span>
                        <span class="cov5" title="9">appstats.IncrementInt(w.statTotalLines)
                        for id, def := range w.cfg.Metrics </span><span class="cov10" title="81">{
                                if w.trace </span><span class="cov0" title="0">{
                                        w.logger.Log().
                                                Int("metric_id", id).
                                                Str("metric_match", def.Matcher.String()).
                                                Str("log_line", line.Text).
                                                Msg("checking rule")
                                }</span>
                                <span class="cov10" title="81">matches := def.Matcher.FindAllStringSubmatch(line.Text, -1)
                                if matches != nil </span><span class="cov5" title="10">{
                                        ml := metricLine{
                                                line:     line.Text,
                                                metricID: id,
                                        }
                                        if len(def.MatchParts) &gt; 0 </span><span class="cov5" title="10">{
                                                m := map[string]string{}
                                                for i, val := range matches[0] </span><span class="cov7" title="24">{
                                                        if def.MatchParts[i] != "" </span><span class="cov6" title="14">{
                                                                m[def.MatchParts[i]] = val
                                                        }</span>
                                                }
                                                <span class="cov5" title="10">ml.matches = &amp;m</span>
                                        }
                                        <span class="cov5" title="10">w.metricLines &lt;- ml</span>
                                        // NOTE: do not 'break' on match, a single
                                        //       line may generate multiple metrics.
                                }
                        }
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// parse log line to extract metric
func (w *Watcher) parse() error <span class="cov3" title="3">{
        for </span><span class="cov6" title="13">{
                select </span>{
                case &lt;-w.t.Dying():<span class="cov3" title="3">
                        return nil</span>
                case l := &lt;-w.metricLines:<span class="cov5" title="10">
                        appstats.IncrementInt(w.statMatchedLines)
                        if w.trace </span><span class="cov0" title="0">{
                                w.logger.Log().
                                        Int("metric_id", l.metricID).
                                        Str("line", l.line).
                                        Interface("matches", l.matches).
                                        Msg("matched, parsing metric line")
                        }</span>

                        <span class="cov5" title="10">r := w.cfg.Metrics[l.metricID]
                        m := metric{
                                Name: fmt.Sprintf("%s`%s", w.cfg.ID, r.Name),
                                Type: r.Type,
                        }

                        if m.Type == "c" </span><span class="cov3" title="4">{
                                m.Value = "1" // default to simple incrment by 1
                        }</span>

                        <span class="cov5" title="10">if l.matches != nil </span><span class="cov5" title="10">{
                                if r.ValueKey != "" </span><span class="cov4" title="7">{
                                        v, ok := (*l.matches)[r.ValueKey]
                                        if !ok </span><span class="cov0" title="0">{
                                                w.logger.Warn().
                                                        Str("value_key", r.ValueKey).
                                                        Str("line", l.line).
                                                        Interface("matches", *l.matches).
                                                        Msg("'Value' key defined but not found in matches")
                                                continue</span>
                                        }
                                        <span class="cov4" title="7">m.Value = v</span>
                                }
                                <span class="cov5" title="10">if r.Namer != nil </span><span class="cov4" title="6">{
                                        var b bytes.Buffer
                                        r.Namer.Execute(&amp;b, *l.matches)
                                        m.Name = fmt.Sprintf("%s`%s", w.cfg.ID, b.String())
                                }</span>
                        }

                        <span class="cov5" title="10">w.metrics &lt;- m</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

// save metrics to configured destination
func (w *Watcher) save() error <span class="cov3" title="3">{
        for </span><span class="cov6" title="13">{
                select </span>{
                case &lt;-w.t.Dying():<span class="cov3" title="3">
                        return nil</span>
                case m := &lt;-w.metrics:<span class="cov5" title="10">
                        w.logger.Info().
                                Str("metric", fmt.Sprintf("%#v", m)).
                                Msg("sending")

                        switch m.Type </span>{
                        case "c":<span class="cov3" title="4">
                                v, err := strconv.ParseUint(m.Value, 10, 64)
                                if err != nil </span><span class="cov0" title="0">{
                                        w.logger.Warn().Err(err).Msg(m.Name)
                                }</span><span class="cov3" title="4"> else {
                                        w.dest.IncrementCounterByValue(m.Name, v)
                                }</span>
                        case "g":<span class="cov2" title="2">
                                w.dest.SetGaugeValue(m.Name, m.Value)</span>
                        case "h":<span class="cov1" title="1">
                                v, err := strconv.ParseFloat(m.Value, 64)
                                if err != nil </span><span class="cov0" title="0">{
                                        w.logger.Warn().Err(err).Msg(m.Name)
                                }</span><span class="cov1" title="1"> else {
                                        w.dest.SetHistogramValue(m.Name, v)
                                }</span>
                        case "ms":<span class="cov1" title="1">
                                // parse as float
                                v, errFloat := strconv.ParseFloat(m.Value, 64)
                                if errFloat == nil </span><span class="cov1" title="1">{
                                        w.dest.SetTimingValue(m.Name, v)
                                        continue</span>
                                }
                                // try parsing as a duration (e.g. 60ms, 1m, 3s)
                                <span class="cov0" title="0">dur, errDuration := time.ParseDuration(m.Value)
                                if errDuration != nil </span><span class="cov0" title="0">{
                                        w.logger.Warn().Err(errFloat).Err(errDuration).Str("metric", m.Name).Msg("failed to parse timing as float or duration")
                                        continue</span>
                                }
                                <span class="cov0" title="0">w.dest.SetTimingValue(m.Name, float64(dur/time.Millisecond))</span>
                        case "s":<span class="cov1" title="1">
                                w.dest.AddSetValue(m.Name, m.Value)</span>
                        case "t":<span class="cov1" title="1">
                                w.dest.SetTextValue(m.Name, m.Value)</span>
                        default:<span class="cov0" title="0">
                                w.logger.Info().
                                        Str("type", m.Type).
                                        Str("name", m.Name).
                                        Interface("val", m.Value).
                                        Msg("metric, unknown type")</span>
                        }
                }
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// Copyright © 2017 Circonus, Inc. &lt;support@circonus.com&gt;
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
//

package main

import (
        "github.com/circonus-labs/circonus-logwatch/cmd"
        "github.com/circonus-labs/circonus-logwatch/internal/release"
)

func main() <span class="cov0" title="0">{
        cmd.Execute()
}</span>

// defined during build (e.g. goreleaser, see .goreleaser.yml)
var (
        version = "dev"
        commit  = "none"
        date    = "unknown"
        tag     = ""
)

func init() <span class="cov8" title="1">{
        release.VERSION = version
        release.COMMIT = commit
        release.DATE = date
        release.TAG = tag
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
